DAY - 4
-- SET OPERATOR 
--UNION , UNION ALL , INTERSECT , MINUS

SELECT EMP_ID ,
       ROLE_NAME
FROM EMPLOYEE_ROLE
INTERSECT
SELECT EMP_ID ,
       ROLE_NAME
FROM ROLE_HISTORY ;

--SELECT 목록은 반드시 동일(컬럼 개수 , 데이터타입)해야 하므로 DUMMY COLUMN을 사용
--HEADING은 첫번째 컬럼의 이름을 따른다. 

SELECT EMP_NAME ,
       JOB_ID , 
       HIRE_DATE
FROM EMPLOYEE
WHERE DEPT_ID = '20'
UNION
SELECT DEPT_NAME ,
       DEPT_ID ,
       NULL
FROM DEPARTMENT
WHERE DEPT_ID = '20' ;


----- 구분
SELECT EMP_ID ,
       EMP_NAME ,
       '관리자' AS 구분
FROM EMPLOYEE
WHERE DEPT_ID = '50'
AND   EMP_ID = '141'
UNION
SELECT EMP_ID ,
       EMP_NAME ,
       '직원' AS 구분
FROM EMPLOYEE
WHERE DEPT_ID = '50'
AND EMP_ID != '141'

--- DECADE ,CASE 구문으로 변환
SELECT EMP_ID ,
       EMP_NAME ,
        DECODE(EMP_ID , '141' , '관리자' , '직원')AS 구분 ,
        CASE WHEN EMP_ID ='141' THEN '관리자'
             ELSE '직원'
             END AS "구분(2)"
FROM EMPLOYEE
WHERE DEPT_ID = '50'
ORDER BY 3 ;

--- JOIN을 이용하여 동일한 결과 출력
--- USING 별칭 불가! 문법 ON 추천
SELECT E.EMP_ID ,
       E.ROLE_NAME
FROM EMPLOYEE_ROLE E
JOIN ROLE_HISTORY R ON (E.EMP_ID = R.EMP_ID AND E.ROLE_NAME = R.ROLE_NAME)

--- SET OPERATOR 
--- 사원테이블에서 대리직급의 이름, 직급과 사원직급의 이름 , 직급을 조회

SELECT EMP_NAME AS 이름 ,
       J.JOB_TITLE AS 직급
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_ID = J.JOB_ID)
WHERE J.JOB_TITLE = '사원'
UNION
SELECT EMP_NAME AS 이름 ,
       J.JOB_TITLE AS 직급
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_ID = J.JOB_ID)
WHERE J.JOB_TITLE = '대리'
ORDER BY 2 ;

--- 위에꺼 IN 연산자
SELECT EMP_NAME AS 이름 ,
       J.JOB_TITLE AS 직급
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_ID = J.JOB_ID)
WHERE J.JOB_TITLE IN ('대리','사원') ;

---SUBQUERY
SELECT (SUBQUERY) - SCALAR
FROM   (SUBQUERY)
WHERE  (SUBQUERY)
GROUP BY (SUBQUERY)
HAVING (SUBQUERY)

-------------------
SELECT EMP_NAME ,
       JOB_ID ,
       SALARY
FROM EMPLOYEE
WHERE JOB_ID = (SELECT JOB_ID
                FROM EMPLOYEE
                WHERE EMP_NAME = '나승원')
AND SALARY > (SELECT SALARY
                FROM EMPLOYEE
                WHERE EMP_NAME = '나승원')

--- 사원테이블에서 최소급여를 받는 사원의 정보를 조회
SELECT *
FROM EMPLOYEE
WHERE SALARY = (SELECT MIN(SALARY)
                FROM EMPLOYEE ) ;
                
---부서별 급여 총합을 조회
SELECT DEPT_NAME ,
       SUM(SALARY)
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
GROUP BY DEPT_NAME
ORDER BY 1

SELECT MAX(SUM(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_ID ;

SELECT DEPT_NAME ,
       SUM(SALARY)
FROM EMPLOYEE
LEFT JOIN DEPARTMENT USING (DEPT_ID)
GROUP BY DEPT_NAME
HAVING SUM(SALARY) = (SELECT MAX(SUM(SALARY))
                       FROM EMPLOYEE
                       GROUP BY DEPT_ID )
ORDER BY 1

--- 관리자들만 출력 
SELECT EMP_ID , 
       EMP_NAME ,
       '관리자' AS 구분
FROM EMPLOYEE
WHERE EMP_ID IN ( SELECT DISTINCT MGR_ID
                   FROM EMPLOYEE
                   WHERE MGR_ID IS NOT NULL) 
UNION
SELECT EMP_ID , 
       EMP_NAME ,
       '직원' AS 구분
FROM EMPLOYEE
WHERE EMP_ID NOT IN ( SELECT DISTINCT MGR_ID
                   FROM EMPLOYEE
                   WHERE MGR_ID IS NOT NULL) ;

-- CASE , DECODE
SELECT EMP_ID ,
       EMP_NAME ,
       CASE WHEN EMP_ID IN ( SELECT DISTINCT MGR_ID
                             FROM EMPLOYEE) THEN '관리자'
            ELSE '직원'
        END AS 구분
FROM EMPLOYEE ;


---- ANY
-- < ANY : 비교 대상 중 최대 값 보다 작음
-- > ANY : 비교 대상 중 최소 값 보다 큼

SELECT EMP_NAME ,
       SALARY 
FROM EMPLOYEE
JOIN JOB USING (JOB_ID)
WHERE JOB_TITLE = '대리'
AND SALARY < ANY (SELECT SALARY
                  FROM   EMPLOYEE
                  JOIN   JOB USING (JOB_ID)
                  WHERE  JOB_TITLE = '과장');
                  
-- 다중 열 SUB QUERY
SELECT EMP_NAME , 
       JOB_TITLE , 
       SALARY
FROM EMPLOYEE
JOIN JOB USING(JOB_ID)
WHERE (JOB_ID , SALARY ) IN (SELECT JOB_ID , TRUNC(AVG(SALARY) , -5)
                             FROM EMPLOYEE
                             GROUP BY JOB_ID) ;
                             
SELECT EMP_NAME ,
       JOB_TITLE , 
       SALARY
FROM   (SELECT JOB_ID , 
        TRUNC(AVG(SALARY), -5) AS JOBAVG
        FROM EMPLOYEE
        GROUP BY JOB_ID ) V
JOIN EMPLOYEE E ON(E.JOB_ID = V.JOB_ID AND E.SALARY =V.JOBAVG)
JOIN JOB J ON (E.JOB_ID = J.JOB_ID) ;


--- 상관관계 서브쿼리 (CORRELATED SUBQUERY)
--- 메인쿼리의 특정 값을 서브 쿼리가 받아 실행 하고 그 결과 값을 메인에 리턴
SELECT EMP_NAME , 
       JOB_TITLE , 
       SALARY
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_ID = J.JOB_ID)
WHERE SALARY = (SELECT TRUNC(AVG(SALARY) , -5 ) AS JOBAVG
                FROM EMPLOYEE S
                WHERE S.JOB_ID = E.JOB_ID )
            
            
---Q 16---
SELECT C.CLASS_NO ,
       C.CLASS_NAME ,
       TRUNC(AVG(POINT),8)
FROM TB_CLASS C
JOIN TB_DEPARTMENT D ON (C.DEPARTMENT_NO = D.DEPARTMENT_NO)
JOIN TB_GRADE G ON (C.CLASS_NO = G.CLASS_NO)
WHERE DEPARTMENT_NAME IN '환경조경학과'
AND SUBSTR(C.CLASS_TYPE,1,2) = '전공'
GROUP BY C.CLASS_NO , C.CLASS_NAME

---Q17---
SELECT STUDENT_NAME ,
       STUDENT_ADDRESS
FROM TB_STUDENT
WHERE DEPARTMENT_NO = (SELECT DEPARTMENT_NO
                       FROM TB_STUDENT
                       WHERE STUDENT_NAME = '최경희')

---Q18---
SELECT K.STUDENT_NO ,
       K.STUDENT_NAME
FROM   (SELECT *
        FROM TB_STUDENT S
        JOIN TB_DEPARTMENT D ON (S.DEPARTMENT_NO = D.DEPARTMENT_NO)
        WHERE DEPARTMENT_NAME = '국어국문학과') K
JOIN TB_GRADE G ON (G.STUDENT_NO = K.STUDENT_NO)
GROUP BY K.STUDENT_NO , K.STUDENT_NAME 
HAVING AVG(G.POINT) = (SELECT  MAX(AVG(G.POINT))
FROM   (SELECT *
        FROM TB_STUDENT S
        JOIN TB_DEPARTMENT D ON (S.DEPARTMENT_NO = D.DEPARTMENT_NO)
        WHERE DEPARTMENT_NAME = '국어국문학과') K
JOIN TB_GRADE G ON (G.STUDENT_NO = K.STUDENT_NO)
GROUP BY K.STUDENT_NO , K.STUDENT_NAME )
                       
---Q19---

SELECT D.DEPARTMENT_NAME AS "계열 학과명" ,
       ROUND(AVG(POINT),1) AS "전공평점"
FROM TB_DEPARTMENT D
JOIN TB_CLASS C ON (D.DEPARTMENT_NO = C.DEPARTMENT_NO)
JOIN TB_GRADE G ON (C.CLASS_NO = G.CLASS_NO)
WHERE CATEGORY = (SELECT CATEGORY
                  FROM TB_DEPARTMENT
                  WHERE DEPARTMENT_NAME IN '환경조경학과')
                  AND SUBSTR(C.CLASS_TYPE,1,2) IN '전공' 
GROUP BY D.DEPARTMENT_NAME
                  
---
